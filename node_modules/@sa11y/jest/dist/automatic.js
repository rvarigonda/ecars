"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerSa11yAutomaticChecks = exports.automaticCheck = exports.skipTest = void 0;
const common_1 = require("@sa11y/common");
const assert_1 = require("@sa11y/assert");
const format_1 = require("@sa11y/format");
const matcher_1 = require("./matcher");
const globals_1 = require("@jest/globals");
/**
 * Default options when {@link registerSa11yAutomaticChecks} is invoked
 */
const defaultAutoCheckOpts = {
    runAfterEach: true,
    cleanupAfterEach: true,
    consolidateResults: true,
    filesFilter: [],
};
/**
 * Check if current test file needs to be skipped based on any provided filter
 */
function skipTest(testPath, filesFilter) {
    if (!testPath || !filesFilter || !(filesFilter?.length > 0))
        return false;
    const skipTest = filesFilter.some((fileName) => testPath.toLowerCase().includes(fileName.toLowerCase()));
    if (skipTest) {
        (0, common_1.log)(`Skipping automatic accessibility check on ${testPath} as it matches given files filter: ${filesFilter.toString()}`);
    }
    return skipTest;
}
exports.skipTest = skipTest;
/**
 * Run accessibility check on each element node in the body using {@link toBeAccessible}
 * @param opts - Options for automatic checks {@link AutoCheckOpts}
 */
async function automaticCheck(opts = defaultAutoCheckOpts) {
    if (skipTest(globals_1.expect.getState().testPath, opts.filesFilter))
        return;
    // Skip automatic check if test is using fake timer as it would result in timeout
    if ((0, matcher_1.isTestUsingFakeTimer)()) {
        (0, common_1.log)('Skipping automatic accessibility check as Jest fake timer is in use.');
        return;
    }
    const violations = [];
    // Create a DOM walker filtering only elements (skipping text, comment nodes etc)
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
    let currNode = walker.firstChild();
    try {
        while (currNode !== null) {
            // TODO (spike): Use a logger lib with log levels selectable at runtime
            // console.log(
            //     `â™¿ [DEBUG] Automatically checking a11y of ${currNode.nodeName}
            //      for test "${expect.getState().currentTestName}"
            //      : ${testPath}`
            // );
            violations.push(...(await (0, assert_1.getViolationsJSDOM)(currNode)));
            currNode = walker.nextSibling();
        }
    }
    finally {
        if (opts.cleanupAfterEach)
            document.body.innerHTML = ''; // remove non-element nodes
        // TODO (spike): Disable stack trace for automatic checks.
        //  Will this affect all errors globally?
        // Error.stackTraceLimit = 0;
        format_1.A11yError.checkAndThrow(violations, { deduplicate: opts.consolidateResults });
    }
}
exports.automaticCheck = automaticCheck;
/**
 * Register accessibility checks to be run automatically after each test
 * @param opts - Options for automatic checks {@link AutoCheckOpts}
 */
function registerSa11yAutomaticChecks(opts = defaultAutoCheckOpts) {
    if (opts.runAfterEach) {
        // TODO (fix): Make registration idempotent
        (0, common_1.log)('Registering sa11y checks to be run automatically after each test');
        afterEach(async () => await automaticCheck(opts));
    }
}
exports.registerSa11yAutomaticChecks = registerSa11yAutomaticChecks;
//# sourceMappingURL=automatic.js.map